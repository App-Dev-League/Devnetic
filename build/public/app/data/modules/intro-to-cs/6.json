{"type":"lesson","pages":[{"type":"information","title":"Intro to USACO Silver","elements":[{"type":"text","content":"➔ Second division of USACO\n➔ Harder than Bronze, but easier than gold or platinum\n➔ Concepts include: Basic Dynamic Programming, Sorting/Searching, Graphs, and more\n"}]},{"type":"information","title":"Partial Sums","elements":[{"type":"text","content":"➔ Given a sequence (a line of values) of length N, answer Q queries asking for the partial sum of the array for different starting and ending indices a and b\n➔ Example: Answer the following 2 queries for the array: [0, 1, 9, 2000, 2]\n[[ ]][[ ]]◆ a = 3, b = 4\n[[ ]][[ ]]◆ a = 0, b = 2\n➔ See the original problem on the next slide\n"},{"type":"divider"},{"type":"text","content":"[[h3]]Original Problem[[/]]\n➔ Problem from [[a]]https://judge.yosupo.jp/problem/static_range_sum[[/a]]"},{"type":"image","src":"./data/modules/intro-to-cs-assets/img6/0-0.png"},{"type":"divider"},{"type":"split-content","elements":[{"type":"text","content":"[[h3]]Naive Approach[[/]]\n➔ For every query, separately go through the array from indices a to b and find the sum\n➔ The problem? This takes too long for large sequences and you will almost definitely exceed USACO’s time limit with this approach\n➔ The time complexity for this approach involves searching N elements of the array for each one of the Q queries, making the overall complexity O(N*Q)\n"},{"type":"text","content":"[[h3]]Accepted Approach[[/]]\n➔ Since there are multiple queries, what we need is a fast way to address each query such that we don't increase the time complexity too much\n➔ To do this, we can use dynamic programming and make a list of all the partial sums from 0 up to each index\n➔ Then, we can use those partial sums to get the partial sum at b and subtract out the partial sum at a - 1 to get the partial sum from a to b.\n"}]},{"type":"divider"},{"type":"text","content":"[[h3]]Code Solution[[/]]"},{"type":"code","lang":"python","content":"def generateList(l):\n  g = [0]\n  for i in range(len(l)):\n    g[i+l] = g[i] + [1]\n  return g\n\ninputs = input().split()\nN = int(inputs[0])\nQ = int(inputs[1])\n\nl = list(map(int, input().split()))\npartialSums = generateList(l)\n\nfor i in range(Q):\n  inputs = input().split()\n  a = int(inputs[0])\n  b = int(inputs[1])\n  print(partialSums[b] - partialSums[a])"},{"type":"divider"},{"type":"text","content":"[[h3]]Code Solution[[/]]\n➔ In the generateList function, we are generating the partial sums for the given list by setting the first index in our new list to be generated (g) to 0 and then iterating over the input list to add each number and create the partial sums list.\n➔ Next, we work on getting our inputs by using the input() function and convert them to ints as needed.\n➔ In the loop at the end, we iterate over each query Q and use our generated list of partial sums to compute the partial sums from a to b\n"}]},{"type":"information","title":"Sorting and Searching","elements":[{"type":"text","content":"[[h3]]Binary Search - introduction[[/]]\n➔ In the generateList function, we are generating the partial sums for the given list by setting the first index in our new list to be generated (g) to 0 and then iterating over the input list to add each number and create the partial sums list.\n➔ Next, we work on getting our inputs by using the input() function and convert them to ints as needed.\n➔ In the loop at the end, we iterate over each query Q and use our generated list of partial sums to compute the partial sums from a to b\n\n➔ One way of solving the above problem might be to simply look through every element in the array and stop once we find the element we are looking for\n➔ This requires a time complexity of O(n) because if n is the size of the array we may need to search all elements before we come to our solution\n➔ However, binary search offers a much faster way of doing this.\n"},{"type":"divider"},{"type":"text","content":"[[h3]]Binary Search - the algorithm[[/]]\n➔ As the name suggests, binary search is based on the idea of division into two parts.\n➔ Here’s the algorithm: We start by checking the middle element of the array. If it is more than the element we are looking for, we now reduce the array into just the left half. \n➔ If it is less than the element we are looking for, we reduce the array into just the right half\n"}]},{"type":"information","title":"Sorting and Searching (continued)","elements":[{"type":"text","content":"[[h3]]Binary Search - walk through[[/]]\n➔ Don’t get it? Let’s walk through it\n➔ Problem: Look for the element 5 in [2, 5, 6, 7, 8, 10, 12, 15, 21]\n➔ The middle element in this array is 8\n➔ 8 is more than 5 so we reduce the array into the left half and search again\n➔ The new problem: Look for the element 5 in [2, 5, 6, 7]\n\n➔ The middle element here is 6\n➔ 6 is more than 5 so we once again look in the left half\n➔ New problem: Look for the element 5 in [2, 5]\n➔ Now the middle element is 5\n➔ 5 is equal to 5 so we have found our result!\n"}]},{"type":"information","title":"Complexity Analysis","elements":[{"type":"text","content":"[[h3]]Binary Search - Complexity Analysis[[/]]\n➔ Now that you saw the algorithm perform, let’s discuss the complexity of this algorithm in terms of time complexity.\n➔ Since we reduce the array to half its original size each time, we will never have to search through all n elements\n➔ However, as we keep going, if our number is in just the right spot, we may need to divide until our sub-array has just one element left in it\n➔ This number of divisions is log2(n)\n➔ Therefore, out time complexity is O(log2(n)) and this is much faster than O(n)!\n"},{"type":"code","content":"def binary_search():\n    arr = [2, 5, 6, 7, 8, 10, 12, 15, 21]\n    target = 5\n    curr = round(len(arr) / 2)\n    while(curr < len(arr) and curr >= 0):\n        if(arr[curr] > target):\n            curr = round(curr/2)\n\n        if(arr[curr] < target):\n            curr = curr + round(curr/2)\n\n        if(arr[curr] == target):\n            return curr","lang":"python"}]},{"type":"information","title":"Graphs","elements":[{"type":"text","content":"[[h3]]Intro to Graphs[[/]]"},{"type":"split-content","elements":[{"type":"text","content":"➔ A graph is a structure made up of nodes, and edges connecting those nodes to form a network.\n➔ In directional graphs, the edges are arrows and point to other nodes, signifying a direction of movement\n➔ In non-directional graphs, the edges are not arrows and this direction of movement is arbitrary.\n"},{"type":"image","src":"./data/modules/intro-to-cs-assets/img6/1-0.png"}]},{"type":"divider"},{"type":"text","content":"[[h3]]Examples of Graphs[[/]]\n➔ Mazes can be represented by graphs, where each space is a node and each way to move is an edge. In this case the graph would be directional.\n➔ The “web” can be represented by a graph because each webpage (node) is connected to the other via hyperlinks (edges)\n➔ Social networking can be represented by a graph, where the nodes could be individual people and edges could connect people who are friends.\n"},{"type":"divider"},{"type":"text","content":"[[h3]]Pathfinding[[/]]\n➔ The pathfinding problem is one of the most famous problems in competitive programming. It involves finding the best way to get from some node in a graph to another node via edges. \n"},{"type":"split-content","elements":[{"type":"text","content":"➔ This is easiest to think of in terms of finding the best path in a maze, which can be represented by a graph.\n"},{"type":"image","src":"./data/modules/intro-to-cs-assets/img6/1-1.png"}]},{"type":"divider"},{"type":"text","content":"[[h3]]Depth First Search [[/]]\n➔ For the silver level of USACO, depth first search (DFS) pops up fairly often. \n➔ DFS is a pathfinding algorithm that involves searching through each possible path until you reach some dead-end.\n➔ Then, the algorithm returns to each previously visited node and explores other paths\n➔ Once the algorithm finds a path to the target node, it returns that path.\n"}]},{"type":"congratulations","title":"Content Review Problems","elements":[{"type":"text","content":"➔ Here are some links to problems that branch from here:\n➔ [[a]]http://www.usaco.org/index.php?page=viewproblem2&cpid=572[[/a]]\n➔ [[a]]http://www.usaco.org/index.php?page=viewproblem2&cpid=715[[/a]]\n➔ [[a]]http://www.usaco.org/index.php?page=viewproblem2&cpid=104[[/a]]\n➔ [[a]]https://atcoder.jp/contests/abc164/tasks/abc164_d[[/a]]\n"}]}]}