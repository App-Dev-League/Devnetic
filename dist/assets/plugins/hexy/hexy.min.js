(function (arg) {

    var hexy = function(buffer, config) {
      const h = new Hexy(buffer, config)
      return h.toString()
    }
    
    var Hexy = function(buffer, config) {
      const self = this
      const MAX_ADDRESS_LENGTH = 8 // TODO: might want to calculate
    
      // if we have a Buffer class, convert
      if (typeof Buffer !== 'undefined') {
        buffer = (Buffer.isBuffer(buffer) && buffer) 
          || (typeof buffer === 'string' && Buffer.from(buffer)) 
          || (buffer && (buffer.constructor === Array) && Buffer.from(buffer)) // accept num arrays
          || Buffer.alloc(0)
      }
      buffer = buffer || []
      config = config || {}
     
      self.buffer         = buffer // magic string conversion here?
      self.bytes_per_line = parseInt(config.width) || 16 // formerly `width`
      self.numbering      = config.numbering == "none" ? "none" : "hex_bytes"
    
      self.bytes_per_group = 2  // by default (not handled below) "fours" will fold into `bytes_per_group == 2`
      switch (config.format) {
        case "none":
          self.bytes_per_group = 0 // one byte per group, but no delimiters
          break
        case "twos":
          self.bytes_per_group = 1
          break
        case "eights":
          self.bytes_per_group = 4
          break
        case "sixteens":
          self.bytes_per_group = 8
          break
      }
                                                                                                       
      self.littleEndian   = config.littleEndian   || false
      self.radix          = config.radix          || 16
      self.caps           = config.caps           == "upper" ? "upper" : "lower"
      self.annotate       = config.annotate       == "none"  ? "none"  : "ascii"
      self.prefix         = config.prefix         || ""
      self.indent         = config.indent         || 0
      self.html           = config.html           || false
      self.offset         = config.offset         || 0
      self.length         = config.length         || -1
      self.extendedChs    = config.extendedChs    || false
      self.display_offset = config.display_offset || 0
    
      if (self.offset) {
        if (self.offset < self.buffer.length) {
          self.buffer = self.buffer.slice(self.offset)
        }
      }
    
      if (self.length !== -1) {
        if (self.length <= self.buffer.length) {
          self.buffer = self.buffer.slice(0, self.length)
        }
      }
    
      self.prefix = (self.html ? "&nbsp;" : " ").repeat(self.indent) + self.prefix
    
      self.hex_line_length = (maxnumberlen(self.bytes_per_group, self.radix)) * self.bytes_per_line
                            / Math.max(self.bytes_per_group, 1)
      switch (self.bytes_per_group) { // the original code (now documented in the tests),
          case 8:                     // some modes had mode-dependent number of extra spaces at the end of the line
          case 4:
          case 2:
            self.hex_line_length += Math.floor(self.bytes_per_line / self.bytes_per_group)
            break
          case 1:
            self.hex_line_length += self.bytes_per_line + 3
            break
          case 0:
            self.hex_line_length += 2
            break
      }
      self.bytes_per_group = Math.min(self.bytes_per_group, self.bytes_per_line)
    
      this.toString = function() {
        var str = ""
        var addr = self.offset + self.display_offset
        var odd = false
    
        if (self.html) { str += "<div class='hexy'>\n" }
    
        // each `slice` is a single output line:
        for (var start = 0; start < self.buffer.length; start += self.bytes_per_line) {
          const end = Math.min(start + self.bytes_per_line, self.buffer.length)
          const slice = self.buffer.slice(start, end)
    
          if (self.html) {
            str += "<div class='" + num2str(addr, MAX_ADDRESS_LENGTH, 16) + (odd ? "  odd" : " even") + "'>"
            odd = !odd
          }
          str += self.prefix
    
          // the address column:
          if (self.numbering === "hex_bytes") {
            str += num2str(addr, MAX_ADDRESS_LENGTH, 16) + ": "
          }
    
          // the binary representation column:
          str += hex(slice, self.bytes_per_line, self.bytes_per_group, self.radix, self.littleEndian)
    
          // the text representation column:
          if (self.annotate === "ascii") {
            var text = ""
            switch (slice.constructor) {
            case Array:
              text = String.fromCharCode.apply(self, slice)
              break
            case Uint8Array:
              slice.forEach(ch => text += String.fromCharCode(ch))
              break
            default:
              text = slice.toString('latin1')
            }
            str += " " + (self.html ? html_escape(text) : ascii_escape(text))
          }
          str += self.html ? "</div>\n" : "\n"
          addr += self.bytes_per_line
        }
    
        if (self.html) { str += "</div>\n" }
        return str
      }
    
      // renders the binary representation of individual line
      var hex = function(buffer, bytes_per_line, bytes_per_group, radix, littleEndian) {
        var str = ""
        const delimiter = bytes_per_group == 0 ? "" : " "
        const group_len = maxnumberlen(bytes_per_group, radix)
        const padlen = (bytes_per_line - buffer.length) * (bytes_per_group == 0 ? group_len: (group_len + 1) / bytes_per_group)
        if (bytes_per_group == 0) {
          bytes_per_group = 1
        }
        const start = littleEndian ? bytes_per_group - 1 : 0
        const end   = littleEndian ? -1 : bytes_per_group
        const step  = littleEndian ? -1 : 1
        for (var group = 0; group < buffer.length / bytes_per_group; ++group) {
          var val = bytes_per_group < 4 ? 0 : BigInt(0)
          for (var ii = start; ii != end; ii += step) {
            const i = group * bytes_per_group + ii
            if (i >= buffer.length) { // not rendering dangling bytes.  TODO: render them as smaller grouping
              break
            }
            if (bytes_per_group < 4) {
              val = val * 256 + ((buffer.constructor == String ? buffer.codePointAt(i) : buffer[i]) & 0xff)
            } else {
              val = BigInt(val) * 256n + BigInt(((buffer.constructor == String ? buffer.codePointAt(i) : buffer[i]) & 0xff))
            }
          }
          const text = val.toString(radix)
          for (var c = 0; c < group_len - text.length; c++) {
            str += "0"
          }
          str += text
          str += delimiter
          if (self.caps === "upper") {
            str = str.toUpperCase()
          }
        }
        if (buffer.length < bytes_per_line) {
          str += (self.html ? "&nbsp;": " ").repeat(padlen)
        }
        str = rpad(str, self.hex_line_length)
        return str
      }
    
      // converts a number to a string and pads it with '0' on the left, up to requested length
      var num2str = function(b, len, radix) {
        const s = b.toString(radix)
        return "0".repeat(len - s.length) + s
      }
    
      var rpad = function(s, len) {
        const to_add = len - s.length - 1
        if (to_add > 0) {
          s += (self.html ? "&nbsp;" : " ").repeat(to_add)
        }
        return s
      }
    
      const ALL_EXCEPT_PRINTABLE_LATIN = /[^\x20-\x7f]/g
      const CONTROL_CHARACTERS_ONLY = /[\x00-\x1f]/g
    
      var ascii_escape = function(str) {
        return str.replace(self.extendedChs ? CONTROL_CHARACTERS_ONLY : ALL_EXCEPT_PRINTABLE_LATIN, ".")
      }
    
      var html_escape = function(str) {
        str = str.replace(/&/g, "&amp;") // `replace()` is measurably faster than `split().join()` in Node.js v.*
        str = str.replace(/</g, "&lt;")
        str = str.replace(/>/g, "&gt;")
        if (self.extendedChs) {
          str = str.replace(/\'/g, "&apos;")
          str = str.replace(/\"/g, "&quot;")
          str = str.replace(ALL_EXCEPT_PRINTABLE_LATIN, function(ch) {
            ch = ch.codePointAt(0)
            return "&#x" + ch.toString(16) + ";"
          })
        } else {
          str = str.replace(ALL_EXCEPT_PRINTABLE_LATIN, ".")
        }
        return str
      }
    }
    
    Hexy.VERSION = "0.3.4"
    
    var maxnumberlen = function(bytes, radix) {
      var result = 2
      if (bytes == 0) {
        bytes = 1
      }
      switch (radix) {
        case 2:       // BIN: 8, 16, 32, 64
          result = bytes * 8
          break
        case 8:       // OCT: 3, 6, 11, 22
          switch (bytes) {
            case 1:
              result = 3
              break
            case 2:
              result = 6
              break
            case 4:
              result = 11
              break
            case 8:
              result = 22
              break
          }
          break
        case 10:      // DEC: 3, 6, 10, 20
          switch (bytes) {
            case 1:
              result = 3
              break
            case 2:
              result = 6
              break
            case 4:
              result = 10
              break
            case 8:
              result = 20
              break
          }
          break
        case 16:      // HEX: 2, 4, 8, 16
          result = 2 * bytes
          break
      }
      return result
    }
    
    
    // This is probably not the prettiest or coolest way to to determine runtime
    // environment. It seems to work and I'm not up to the task figuring out what
    // the module system du jour is and how to interface with it ...
    
    // If anyone wants to fix this to include this module "properly", I'm more than
    // happy to incorporate any fixes...
    
    var _exp
    if (typeof exports !== "undefined") {
      _exp = exports
    } else if (arg === window) {
      _exp = window
    } else {
      // who knows?
      _exp = arg // or this or somethings. ...
    }
    _exp.hexy = hexy
    _exp.Hexy = Hexy
    _exp.maxnumberlen = maxnumberlen
    
    })(this)